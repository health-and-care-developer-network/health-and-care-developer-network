<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Sparse Columns</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="7d4237e0-818f-4639-9093-d5ac9683fc71" /><meta name="Description" content="Sparse columns are ordinary columns that have an optimized storage for null values. Sparse columns reduce the space requirements for null values at the cost of more overhead to retrieve non null values." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Sparse Columns</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Sparse columns are ordinary columns that have an optimized storage for null values. Sparse columns reduce the space requirements for null values at the cost of more overhead to retrieve non null values. Consider using sparse columns when the space saved is at least 20 percent to 40 percent.</p><p>The SQL Server JDBC Driver 3.0 supports sparse columns when you connect to a SQL Server 2008 (or later) server. You can use <a href="f173fa5d-e114-4a37-a5c4-2baad9ff3af1.htm">SQLServerDatabaseMetaData.getColumns</a>, <a href="e2b0e0f7-717c-48e6-bcd2-a325d938a833.htm">SQLServerDatabaseMetaData.getFunctionColumns</a>, or <a href="4f0df8fe-3cd6-46e4-ae3c-dc23c35676b2.htm">SQLServerDatabaseMetaData.getProcedureColumns</a> to determine which column is sparse and which column is the column set column.</p><p>Column sets are computed columns that return all sparse columns in untyped XML form. You should consider using column sets when the number of columns in a table is large or greater than 1024 or operating on individual sparse columns is cumbersome. A column set can contain up to 30,000 columns.</p></div><h1 class="heading">Example</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><h1 class="heading">Description</h1><div class="subsection"><p>This sample demonstrates how to detect column sets. It also shows how to parse a column set's XML output to get the data from the sparse columns.</p><p>The first code listing is the Transact-SQL you should run on the server.</p><p>The second code listing is the Java source code. Before you compile the application, change the name of the server in the connection string.</p></div><h1 class="heading">Code</h1><div class="subsection"><div class="sampleCode"><span codeLanguage="other"><pre>use AdventureWorks
CREATE TABLE ColdCalling
(
ID int IDENTITY(1,1) PRIMARY KEY,
[Date] date,
[Time] time,
PositiveFirstName nvarchar(50) SPARSE,
PositiveLastName nvarchar(50) SPARSE,
SpecialPurposeColumns XML COLUMN_SET FOR ALL_SPARSE_COLUMNS
);
GO

INSERT ColdCalling ([Date], [Time])
VALUES ('10-13-09','07:05:24')
GO
      
INSERT ColdCalling ([Date], [Time], PositiveFirstName, PositiveLastName)
VALUES ('07-20-09','05:00:24', 'AA', 'B')
GO
      
INSERT ColdCalling ([Date], [Time], PositiveFirstName, PositiveLastName)
VALUES ('07-20-09','05:15:00', 'CC', 'DD')
GO</pre></span></div></div><h1 class="heading">Code</h1><div class="subsection"><div class="sampleCode"><span codeLanguage="other"><pre>import java.sql.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.xml.sax.InputSource;

import java.io.StringReader;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class SparseColumns {

   public static void main(String args[]) {
      final String connectionUrl = "jdbc:sqlserver://my_server;databaseName=AdventureWorks;integratedSecurity=true;";
      
      Connection conn = null;
      Statement stmt = null;
      ResultSet rs = null;
      
      try {
         conn = DriverManager.getConnection(connectionUrl);
         
         stmt = conn.createStatement();
         // Determine the column set column
         String columnSetColName = null;
         String strCmd = "SELECT name FROM sys.columns WHERE object_id=(SELECT OBJECT_ID('ColdCalling')) AND is_column_set = 1";
         rs = stmt.executeQuery(strCmd);
         
         if (rs.next()) {
            columnSetColName = rs.getString(1);
            System.out.println(columnSetColName + " is the column set column!");
         }
         rs.close();

         rs = null; 
             
         strCmd = "SELECT * FROM ColdCalling";
         rs = stmt.executeQuery(strCmd);
            
         // Iterate through the result set
         ResultSetMetaData rsmd = rs.getMetaData();
         
         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
         DocumentBuilder db = dbf.newDocumentBuilder();
         InputSource is = new InputSource();
         while (rs.next()) {
            // Iterate through the columns
            for (int i = 1; i &lt;= rsmd.getColumnCount(); ++i) {
               String name = rsmd.getColumnName(i);
               String value = rs.getString(i);
   
               // If this is the column set column
               if (name.equalsIgnoreCase(columnSetColName)) {
                  System.out.println(name);
                  
                  // Instead of printing the raw XML, parse it
                  if (value != null) {
                     // Add artificial root node "sparse" to ensure XML is well formed
                     String xml = "&lt;sparse&gt;" + value + "&lt;/sparse&gt;";
   
                     is.setCharacterStream(new StringReader(xml));
                     Document doc = db.parse(is);
   
                     // Extract the NodeList from the artificial root node that was added
                     NodeList list = doc.getChildNodes();
                     // This is the &lt;sparse&gt; node
                     Node root = list.item(0); 
                     // These are the xml column nodes
                     NodeList sparseColumnList = root.getChildNodes(); 
   
                     // Iterate through the XML document
                     for (int n = 0; n &lt; sparseColumnList.getLength(); ++n) {
                        Node sparseColumnNode = sparseColumnList.item(n);
                        String columnName = sparseColumnNode.getNodeName();
                        // Note that the column value is not in the sparseColumNode, it is the value of the first child of it
                        Node sparseColumnValueNode = sparseColumnNode.getFirstChild();
                        String columnValue = sparseColumnValueNode.getNodeValue();
                        
                        System.out.println("\t" + columnName + "\t: " + columnValue);
                     }
                  }
               } else {   // Just print the name + value of non-sparse columns
                  System.out.println(name + "\t: " + value);
               }
            }
            System.out.println();//New line between rows
         }
      } catch (Exception e) {
         e.printStackTrace();
      } finally {
         if (rs != null) {
            try {
               rs.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
         if (stmt != null) {
            try {
               stmt.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
         if (conn != null) {
            try {
               conn.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
      }
   }      
}</pre></span></div></div></div><span id="seeAlsoSpan"><h1 class="heading">See Also</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="e1592499-b87b-45ee-bab8-beaba8fde841.htm">Improving Performance and Reliability with the JDBC Driver</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Send <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','01.00.12024.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/en-us/default.aspx.%0\A%0\d','Customer%20Feedback');">feedback</a> on this topic to Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft.  All rights reserved.</a></p></span></div></div></body></html>